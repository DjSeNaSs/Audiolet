var AudioletBuffer = new Class({
    initialize: function(numberOfChannels, length, sampleRate) {
        this.numberOfChannels = numberOfChannels;
        this.sampleRate = sampleRate;
        this.length = length;

        this.duration = this.length / this.sampleRate;

        this.data = new Float32Array(numberOfChannels * length);
        this.unsliced_data = this.data;
    },

    getChannelData: function(channel) {
        return (this.data.subarray(channel * this.length,
                               (channel + 1) * this.length));
    },

    add: function(buffer) {
        var length = this.length;
        var numberOfChannels = buffer.numberOfChannels;
        for (var i = 0; i < numberOfChannels; i++) {
            var channel1 = this.getChannelData(i);
            var channel2 = buffer.getChannelData(i);
            for (var j = 0; j < length; j++) {
                channel1[j] += channel2[j];
            }
        }
    },

    resize: function(numberOfChannels, length) {
        if (numberOfChannels * length > this.unsliced_data.length) {
            this.data = new Float32Array(numberOfChannels * length);
            this.unsliced_data = this.data;
        }
        else {
            var numberOfSamples = numberOfChannels * length;
            this.data = this.unsliced_data.subarray(0, numberOfSamples);
        }
        this.numberOfChannels = numberOfChannels;
        this.length = length;
    },

    interleave: function() {
        var numberOfSamples = this.numberOfChannels * this.length;
        var interleaved = new Float32Array(this.numberOfSamples);
        var leftChannel = this.getChannelData(0);
        var rightChannel = this.getChannelData(1);
        var length = this.length;
        for (var i = 0; i < length; i++) {
            interleaved[2 * i] = leftChannel[i];
            interleaved[2 * i + 1] = rightChannel[i];
        }
        this.data = interleaved;
    }
});

/**
 * @depends AudioletBuffer.js
 */

var AudioletInput = new Class({
    initialize: function(node, index) {
        this.node = node;
        this.index = index;
        this.connectedFrom = [];
        // Minimum sized buffer, which we can resize from accordingly
        this.buffer = new AudioletBuffer(2, 1, node.context.sampleRate);
    },

    connect: function(output) {
        this.connectedFrom.push(output);
    },

    disconnect: function(output) {
        var numberOfStreams = this.connectedFrom.length;
        for (var i = 0; i < numberOfStreams; i++) {
            if (output == this.connectedFrom[i]) {
                this.connectedFrom.splice(i, 1);
                break;
            }
        }
    }
});


/**
 * @depends AudioletBuffer.js
 */

var AudioletOutput = new Class({
    initialize: function(node, index) {
        this.node = node;
        this.index = index;
        this.connectedTo = [];
        // Minimum sized buffer, which we can resize from accordingly
        this.buffer = new AudioletBuffer(2, 1, node.context.sampleRate);
    },

    connect: function(input) {
        this.connectedTo.push(input);
    },

    disconnect: function(input) {
        var numberOfStreams = this.connectedTo.length;
        for (var i = 0; i < numberOfStreams; i++) {
            if (input == this.connectedTo[i]) {
                this.connectedTo.splice(i, 1);
                break;
            }
        }
    }
});


/**
 * @depends AudioletInput.js
 * @depends AudioletOutput.js
 */

var AudioletNode = new Class({
    initialize: function(audiolet, numberOfInputs, numberOfOutputs) {
        this.audiolet = audiolet;
        this.numberOfInputs = numberOfInputs;
        this.numberOfOutputs = numberOfOutputs;

        this.inputs = [];
        var numberOfInputs = this.numberOfInputs;
        for (var i = 0; i < numberOfInputs; i++) {
            this.inputs.push(new AudioletInput(this, i));
        }

        this.outputs = [];
        var numberOfOutputs = this.numberOfOutputs;
        for (var i = 0; i < numberOfOutputs; i++) {
            this.outputs.push(new AudioletOutput(this, i));
        }
    },

    connect: function(node, output, input) {
        var outputPin = this.outputs[output || 0];
        var inputPin = node.inputs[input || 0];
        outputPin.connect(inputPin);
        inputPin.connect(outputPin);
    },

    disconnect: function(output) {
        var outputPin = this.outputs[output || 0];
        while (outputPin.connectedTo.length) {
            var inputPin = outputPin.connectedTo.pop();
            inputPin.disconnect(outputPin);
            outputPin.disconnect(inputPin);
        }
    },

    tick: function(length) {
        this.tickParents(length);

        var inputBuffers = this.createInputBuffers(length);
        var outputBuffers = this.createOutputBuffers(length);
        this.generate(inputBuffers, outputBuffers);
    },

    tickParents: function(length) {
        var numberOfInputs = this.numberOfInputs;
        for (var i = 0; i < numberOfInputs; i++) {
            var input = this.inputs[i];
            var numberOfStreams = input.connectedFrom.length;
            for (var j = 0; j < numberOfStreams; j++) {
                input.connectedFrom[j].node.tick(length);
            }
        }
    },

    // Overwrite me!
    generate: function(inputBuffers, outputBuffers) {
    },

    createInputBuffers: function(length) {
        var inputBuffers = [];
        var numberOfInputs = this.numberOfInputs;
        for (var i = 0; i < numberOfInputs; i++) {
            var input = this.inputs[i];

            var numberOfStreams = input.connectedFrom.length;
            if (numberOfStreams) {
                // We have connections
                var inputBuffer = input.connectedFrom[0].buffer;

                // Sum the other inputs
                for (var j = 1; j < numberOfStreams; j++) {
                    var output = input.connectedFrom[j];
                    var outputBuffer = output.buffer;
                    inputBuffer.add(outputBuffer);
                }
            }
            else {
                // If we don't have any connections give a single silent channel
                inputBuffer.resize(2, length);
            }
            inputBuffers.push(inputBuffer);
        }
        return (inputBuffers);
    },

    createOutputBuffers: function(event, length) {
        // Create the output buffers
        var outputBuffers = [];
        var numberOfOutputs = this.numberOfOutputs;
        for (var i = 0; i < numberOfOutputs; i++) {
            var output = this.outputs[i];
            output.buffer.resize(2, length);
            outputBuffers.push(output.buffer);
        }
        return (outputBuffers);
    }
});


/**
 * @depends AudioletNode.js
 */
var AbstractAudioletDevice = new Class({
    Extends: AudioletNode,
    initialize: function(audiolet) {
        AudioletNode.prototype.initialize.apply(this, [audiolet, 1, 0]);
        this.audiolet = audiolet;
        this.numChannels = this.audiolet.numChannels;
        this.sampleRate = this.audiolet.sampleRate;
        this.bufferSize = this.audiolet.bufferSize;
        this.buffer = null;
    },

    generate: function(inputBuffers, outputBuffers) {
        this.buffer = inputBuffers[0];
    },

    getTime: function() {
        return 0;
    }
});


/**
 * @depends AbstractAudioletDevice.js
 */

var AudioDataAPIDevice = new Class({
    Extends: AbstractAudioletDevice,
    initialize: function(audiolet) {
        AbstractAudioletDevice.prototype.initialize.apply(this, [audiolet]);
        this.numChannels = numChannels || 2;
        this.sampleRate = sampleRate || 44100.0;
        this.bufferSize = bufferSize || 32784;

        this.output = new Audio();
        this.overflow = null;
        this.writePosition = 0;

        this.output.mozSetup(this.numChannels, this.sampleRate);
    },

    tick: function() {
        // Check if some data was not written in previous attempts
        var numSamplesWritten;
        if (this.overflow) {
            numSamplesWritten = this.output.mozWriteAudio(this.overflow);
            this.writePosition += numSamplesWritten;
            if (numSamplesWritten < this.overflow.length) {
                // Not all the data was written, saving the tail for writing
                // the next time tick is called
                this.overflow = this.overflow.subarray(numSamplesWritten);
                return;
            }
            this.overflow = null;
        }

        // Check if we need add some data to the audio output.
        var outputPosition = this.output.mozCurrentSampleOffset();
        var samplesNeeded = outputPosition + this.bufferSize -
                            this.writePosition;
        if (samplesNeeded > 0) {
            // Pull data from connected nodes
            AudioletNode.prototype.tick.apply(this, [samplesNeeded]);
            // Interleave so it's in the right output format
            this.buffer.interleave();

            // Writing the data.
            numSamplesWritten = this.output.mozWriteAudio(this.buffer);
            if (numSamplesWritten < buffer.length) {
                // Not all the data was written, saving the tail.
                this.overflow = buffer.subarray(numSamplesWritten);
            }
            this.writePosition += numSamplesWritten;
        }
    },

    getTime: function() {
        return this.output.mozCurrentSampleOffset();
    }
});


/**
 * @depends AbstractAudioletDevice.js
 */

var DummyDevice = new Class({
    Extends: AbstractAudioletDevice,
    initialize: function(audiolet) {
        AbstractAudioletDevice.prototype.initialize.apply(this, [audiolet]);
    },

    tick: function() {
    }
});


/**
 * @depends AudioDataAPIDevice.js
 * @depnds WebAudioAPIDevice.js
 * @depends DummyDevice.js
 */

function AudioletDevice(audiolet, sampleRate, numberOfChannels, bufferSize) {
    // Mozilla?
    var tmpAudio = new Audio();
    var haveAudioDataAPI = (typeof tmpAudio.mozSetup == 'function');
    tmpAudio = null;
    if (haveAudioDataAPI) {
        return new AudioDataAPIDevice();
    }
    // Webkit?
    else if (typeof AudioContext != 'undefined') {
        return new WebAudioAPIDevice();
    }
    else {
        return new DummyDevice();
    }
}


// Priority Queue based on python heapq module
// http://svn.python.org/view/python/branches/release27-maint/Lib/heapq.py
var PriorityQueue = new Class({
    initialize: function(array, compare) {
        if (compare) {
            this.compare = compare;
        }

        if (array) {
            this.heap = array;
            for (var i = 0; i < Math.floor(this.heap.length / 2); i++) {
                this.siftUp(i);
            }
        }
        else {
            this.heap = [];
        }
    },

    push: function(item) {
        this.heap.add(item);
        this.siftDown(0, this.heap.length - 1);
    },


    pop: function() {
        var lastElement, returnItem;
        lastElement = this.heap.pop();
        if (this.heap.length) {
            var returnItem = this.heap[0];
            this.heap[0] = lastElement;
            this.siftUp(0);
        }
        else {
            returnItem = lastElement;
        }
        return (returnItem);
    },

    peek: function() {
        return (this.heap[0]);
    },

    siftDown: function(startPosition, position) {
        var newItem = this.heap[position];
        while (position > startPosition) {
            var parentPosition = (position - 1) >> 1;
            var parent = this.heap[parentPosition];
            if (this.compare(newItem, parent)) {
                this.heap[position] = parent;
                position = parentPosition;
                continue;
            }
            break;
        }
        this.heap[position] = newItem;
    },

    siftUp: function(position) {
        var endPosition = this.heap.length;
        var startPosition = position;
        var newItem = this.heap[position];
        var childPosition = 2 * position + 1;
        while (childPosition < endPosition) {
            var rightPosition = childPosition + 1;
            if (rightPosition < endPosition &&
                !this.compare(this.heap[childPosition],
                              this.heap[rightPosition])) {
                childPosition = rightPosition;
            }
            this.heap[position] = this.heap[childposition];
            position = childPosition;
            childPosition = 2 * position + 1;
        }
        this.heap[position] = newItem;
        siftDown(startPosition, position);
    },

    compare(a, b) {
        return (a < b);
    }
});

/**
 * @depends AudioletNode.js
 * @depends PriorityQueue.js
 */

var Scheduler = new Class({
    Extends: AudioletNode,
    initialize: function(audiolet, bpm) {
        AudioletNode.prototype.initialize.apply(this, [audiolet, 1, 1]);
        this.bpm = bpm || 120;
        this.queue = new PriorityQueue(null, function(a, b) {
            return (a.time < b.time);
        });

        this.time = 0;
        this.beats = 0;
        this.bar = 0;
        this.seconds = 0;
        this.beatsPerBar = 0;

        this.lastBeatTime = 0;
        this.beatLength = 60 / this.bpm * this.audiolet.sampleRate;
    },

    addRelative: function(beats, callback) {
    },

    addAbsolute: function(beat, callback) {
    },

    remove: function() {
    },

    tick: function(length) {
        // The time at the beginning of the block
        var startTime = this.audiolet.device.getTime();

        // Update the clock so it is correct for the first samples
        this.updateClock(startTime);

        // Create the output buffer which contains the whole block
        var outputBuffers = this.createOutputBuffers(length);

        // Generate the block of samples and carry out events, generating a
        // new sub-block each time an event is carried out
        var lastEventTime = startTime;
        while (this.queue.peek().time <= startTime + length) {
            var event = this.queue.pop();

            // Generate samples to take us to the event
            var timeToEvent = event.time - lastEventTime;
            this.tickParents(timeToEvent);

            // Get the summed input
            var inputBuffers = this.createInputBuffers(length);

            // Copy it to the right part of the output
            // Use the generate function so it looks and quacks like an
            // AudioletNode
            var offset = lastEventTime - startTime;
            this.generate(outputBuffers, inputBuffers, offset);

            // Update the clock so it is correct for the current event
            this.updateClock(event.time);

            // Carry out the event
            event.callback();
            lastEventTime = event.time;
        }

        // Generate enough samples to complete the block
        var remainingTime = startTime + length - lastEventTime;
        if (remainingTime) {
            this.tickParents(timeToEvent);
            var inputBuffers = this.createInputBuffers(length);
            var offset = lastEventTime - startTime;
            this.generate(outputBuffers, inputBuffers, offset);
        }
    },

    updateClock: function(time) {
        this.time = time;
        this.seconds = this.time * this.audiolet.sampleRate;
        if (this.time >= this.lastBeatTime + this.beatLength) {
            this.beat += 1;
            if (this.beat == this.beatsPerBar) {
                this.beat = 0;
                this.bar += 1;
            }
            this.lastBeatTime += this.beatLength;
        }
    },

    generate: function(inputBuffers, outputBuffers, offset) {
        var inputBuffer = inputBuffers[0];
        var outputBuffer = outputBuffers[0];
        for (var i = 0; i < inputBuffer.numberOfChannels; i++) {
            var inputChannel = inputBuffer.getChannelData(i);
            var outputChannel = outputBuffer.getChannelData(i);
            outputChannel.set(inputChannel, offset);
        }
    }
});

/**
 * @depends Scheduler.js
 * @depends AudioletDevice.js
 */

var Audiolet = new Class({
    initialize: function(sampleRate, numberOfChannels, bufferSize) {
        this.output = new AudioletDevice(audiolet, sampleRate,
                                         numberOfChannels, bufferSize);
        this.scheduler = new Scheduler(audiolet);
        this.scheduler.connect(this.output);
    }
});


/**
 * @depends AbstractAudioletDevice.js
 */

var WebAudioAPIDevice = new Class({
    Extends: AbstractAudioletDevice,
    initialize: function(audiolet) {
        AbstractAudioletDevice.prototype.initialize.apply(this, [audiolet]);
        // AudioContext is called webkitAudioContext in the current
        // implementation, so look for either
        var AudioContext, webkitAudioContext;
        AudioContext = AudioContext || webkitAudioContext;
        this.context = new AudioContext(this.sampleRate);

        this.node = this.context.createJavaScriptAudioNode(this.bufferSize, 1,
                                                           1);

        this.node.onprocessaudio = this.tick;
    },

    tick: function(event) {
        var buffer = event.outputBuffer[0];
        var samplesNeeded = buffer.length;
        AudioletNode.prototype.tick.apply(this, [samplesNeeded]);
        var numberOfChannels = buffer.numberOfChannels;
        for (var i = 0; i < numberOfChannels; i++) {
            var channel = buffer.getChannelData(i);
            channel.set(this.buffer.getChannelData(i));
        }
    },

    getTime: function() {
        return this.context.currentTime;
    }
});


/**
 * @depends ../core/AudioletNode.js
 */

var Gain = new Class({
    Extends: AudioletNode,
    initialize: function(audiolet) {
        AudioletNode.prototype.initialize.apply(this, [audiolet, 1, 1]);
        this.gain = 1;
    },

    generate: function(inputBuffers, outputBuffers) {
        var inputBuffer = inputBuffers[0];
        var outputBuffer = outputBuffers[0];

        // Local processing variables
        var gain = this.gain;

        var numberOfChannels = inputBuffer.numberOfChannels;
        for (var i = 0; i < numberOfChannels; i++) {
            var inputChannel = inputBuffer.getChannelData(i);
            var outputChannel = outputBuffer.getChannelData(i);
            var bufferLength = inputBuffer.length;
            for (var j = 0; j < bufferLength; j++) {
                outputChannel[j] = inputChannel[j] * gain;
            }
        }
        this.gain = gain;
    }
});


/**
 * @depends ../core/AudioletNode.js
 */

var Pan = new Class({
    Extends: AudioletNode,
    initialize: function(audiolet) {
        AudioletNode.prototype.initialize.apply(this, [audiolet, 1, 1]);
        this.pan = 0.5;
    },

    generate: function(inputBuffers, outputBuffers) {
        var inputBuffer = inputBuffers[0];
        var outputBuffer = outputBuffers[0];
        var inputChannel = inputBuffer.getChannelData(0);
        var leftOutputChannel = outputBuffer.getChannelData(0);
        var rightOutputChannel = outputBuffer.getChannelData(1);

        // Local processing variables
        var pan = this.pan;
        var leftGain = Math.cos(pan * Math.PI / 2);
        var rightGain = Math.sin(pan * Math.PI / 2);

        var bufferLength = outputBuffer.length;
        for (var i = 0; i < bufferLength; i++) {
            var value = inputChannel[i];
            leftOutputChannel[i] = value * leftGain;
            rightOutputChannel[i] = value * rightGain;
        }
        this.pan = pan;
    }
});

/**
 * @depends ../core/AudioletNode.js
 */
var Sine = new Class({
    Extends: AudioletNode,
    initialize: function(audiolet) {
        AudioletNode.prototype.initialize.apply(this, [audiolet, 0, 1]);
        this.phase = 0;
        this.frequency = 440;
    },

    generate: function(inputBuffers, outputBuffers) {
        var buffer = outputBuffers[0];
        var channel = buffer.getChannelData(0);

        // Make processing variables local
        var sampleRate = this.audiolet.sampleRate;
        var tableSize = Sine.TABLE.length;
        var phase = this.phase;
        var frequency = this.frequency;

        // Processing loop
        var bufferLength = buffer.length;
        for (var i = 0; i < bufferLength; i++) {
            var step = frequency * tableSize / sampleRate;
            phase += step;
            phase &= tableSize - 1; // this.phase %= tableSize
            channel[i] = Sine.TABLE[Math.floor(phase)];
        }
        this.phase = phase;
        this.frequency = frequency;
    }
});

Sine.TABLE = [];
for (var i = 0; i < 2048; i++) {
    Sine.TABLE.push(Math.sin(i * 2 * Math.PI / 2048));
}


var Pattern = new Class({
    initialize: function() {
    },

    next: function() {
        return null;
    },

    value: function(item) {
        if (isInstance(item, Pattern)) {
           return (item.next());
        }
        else {
            return (item);
        }
    },

    reset: function() {
    }
});


/**
 * @depends Pattern.js
 */

var PArithmetic = new Class({
    Extends: Pattern,
    initialize: function(start, step, repeats) {
        Pattern.prototype.initialize.apply(this);
        this.value = start;
        this.step = step;
        this.repeats = repeats;
        this.position = 0;
    },

    next: function() {
        var returnValue;
        if (this.position < this.repeats) {
            var step = this.value(this.step);
            if (step != null) {
                this.value += step;
                returnValue = this.value;
                this.position += 1;
            }
            else {
                returnValue = null;
            }
        }
        else {
            returnValue = null;
        }
        return (returnValue);
    }
});

var Pseries = PArithmetic;


/**
 * @depends Pattern.js
 */

var PChoose = new Class({
    Extends: Pattern,
    initialize: function(list, repeats) {
        Pattern.prototype.initialize.apply(this);
        this.list = list;
        this.repeats = repeats || 1;
        this.position = 0;
    },

    next: function() {
        var returnValue;
        if (this.position < this.repeats) {
            var index = Math.floor(Math.random() * this.list.length);
            var item = this.list[index];
            var value = this.value(item);
            if (value != null) {
                if (!isInstance(item, Pattern) {
                    this.position += 1;
                }
                returnValue = value;
            }
            else {
                this.position += 1;
                returnValue = this.next();
            }
        }
        else {
            returnValue = null;
        }
        return (returnValue);
    }
});
var Prand = PChoose;


/**
 * @depends Pattern.js
 */

var PGeometric = new Class({
    Extends: Pattern,
    initialize: function(start, step, repeats) {
        Pattern.prototype.initialize(this);
        this.value = start;
        this.step = step;
        this.repeats = repeats;
        this.position = 0;
    },

    next: function() {
        var returnValue;
        if (this.position < this.repeats) {
            var step = this.value(this.step);
            if (step != null) {
                this.value *= step;
                returnValue = this.value;
                this.position += 1;
            }
            else {
                returnValue = null;
            }
        }
        else {
            returnValue = null;
        }
        return (returnValue);
    }
});
var Pgeom = PGeometric;


/**
 * @depends Pattern.js
 */

var PRandom = new Class({
    Extends: Pattern,
    initialize: function(low, high, repeats) {
        Pattern.prototype.initialize(this);
        this.low = low;
        this.high = high;
        this.repeats = repeats;
        this.position = 0;
    },

    next: function() {
        var returnValue;
        if (this.position < this.repeats) {
            var low = this.value(this.low);
            var high = this.value(this.high);
            if (low != null && high != null) {
                this.value *= step;
                returnValue = this.value;
                this.position += 1;
            }
            else {
                returnValue = null;
            }
        }
        else {
            returnValue = null;
        }
        return (returnValue);
    }
});
var Pwhite = PRandom;


/**
 * @depends Pattern.js
 */

var PSequence = new Class({
    Extends: Pattern,
    initialize: function(list, repeats, offset) {
        Pattern.prototype.initialize(this);
        this.list = list;
        this.repeats = repeats || 1;
        this.position = 0;
        this.offset = offset;
    },

    next: function() {
        var returnValue;
        if (this.position < this.repeats * this.list.length) {
            var index = (this.position + this.offset) % this.list.length;
            var item = this.list[index];
            var value = this.value(item);
            if (value != null) {
                if (!isInstance(item, Pattern) {
                    this.position += 1;
                }
                returnValue = value;
            }
            else {
                this.position += 1;
                returnValue = this.next();
            }
        }
        else {
            returnValue = null;
        }
        return (returnValue);
    }
});
var Pseq = PSequence;


/**
 * @depends Pattern.js
 */

var PSeries = new Class({
    Extends: Pattern,
    initialize: function(list, repeats, offset) {
        Pattern.prototype.initialize(this);
        this.list = list;
        this.repeats = repeats || 1;
        this.position = 0;
        this.offset = offset;
    },

    next: function() {
        var returnValue;
        if (this.position < this.repeats) {
            var index = (this.position + this.offset) % this.list.length;
            var item = this.list[index];
            var value = this.value(item);
            if (value != null) {
                if (!isInstance(item, Pattern) {
                    this.position += 1;
                }
                returnValue = value;
            }
            else {
                this.position += 1;
                returnValue = this.next();
            }
        }
        else {
            returnValue = null;
        }
        return (returnValue);
    }
});
var Pser = PSeries;


/**
 * @depends Pattern.js
 * @depends PSequence.js
 */

var PShuffle = new Class({
    Extends: Pattern,
    Implements: PSequence, // Use the same next function
    initialize: function(list, repeats) {
        Pattern.prototype.initialize(this);
        this.list = [];
        // Shuffle values into new list
        while (list.length) {
            var index = Math.floor(Math.random() * list.length);
            var value = list.splice(index, 1);
            this.list.push(value);
        }
        this.repeats = repeats;
        this.position = 0;
    }
});

var Pshuffle = PShuffle;


/**
 * @depends Pattern.js
 */

var PWeightedChoose = new Class({
    Extends: Pattern,
    initialize: function() {
        Pattern.prototype.initialize(this);
    },

    next: function() {
    }
});

Pwrand = PWeightedChoose;

